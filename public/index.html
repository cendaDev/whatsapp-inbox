<!doctype html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <title>WhatsApp Inbox – CENDA</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="app">
    <div class="sidebar">
        <div class="header">Conversaciones</div>
        <div class="search-box">
            <input id="search" type="text" placeholder="Buscar teléfono..." />
        </div>
        <div id="chats"></div>
    </div>
    <div class="content">
        <div class="header" id="title">Selecciona un chat</div>
        <div class="messages" id="messages"><div class="empty">No hay chat seleccionado</div></div>
        <div class="composer">
            <input id="to" type="text" placeholder="Teléfono E.164 (ej. 573001112233)" />
            <input id="text" type="text" placeholder="Escribe un mensaje…" />
            <button id="send">Enviar</button>
        </div>
    </div>
</div>

<script>
    let data = [];
    let selectedPhone = null;
    let searchTerm = "";

    const elChats = document.getElementById("chats");
    const elMsgs  = document.getElementById("messages");
    const elTitle = document.getElementById("title");
    const elTo    = document.getElementById("to");
    const elText  = document.getElementById("text");
    const elSend  = document.getElementById("send");
    const elSearch = document.getElementById("search");

    elSearch.oninput = (e) => {
        searchTerm = e.target.value.toLowerCase().trim();
        renderChats();
    };

    function fmt(ts){
        const d = new Date((ts||0)*1000);
        return isNaN(d) ? "" : d.toLocaleString();
    }

    function renderChats() {
        elChats.innerHTML = "";

        const filtered = data.filter(conv => {
            if (!searchTerm) return true;
            return conv.phone.toLowerCase().includes(searchTerm) ||
                (conv.name && conv.name.toLowerCase().includes(searchTerm));
        });

        // Ordenar: primero los no leídos, luego por timestamp
        filtered.sort((a, b) => {
            const aHasUnread = a.messages.some(m => m.direction === "in" && !m.read);
            const bHasUnread = b.messages.some(m => m.direction === "in" && !m.read);

            if (aHasUnread && !bHasUnread) return -1;
            if (!aHasUnread && bHasUnread) return 1;

            return (b.last_ts || 0) - (a.last_ts || 0);
        });

        filtered.forEach(conv => {
            const div = document.createElement("div");
            div.className = "chat";

            // Solo marcar como no leído si hay mensajes entrantes sin leer
            const hasUnread = conv.messages.some(m => m.direction === "in" && !m.read);

            if (hasUnread) {
                div.classList.add("unread");
            }

            if (conv.phone === selectedPhone) {
                div.classList.add("selected");
            }

            div.onclick = () => {
                selectedPhone = conv.phone;
                elTo.value = conv.phone;

                // Marcar mensajes entrantes como leídos
                conv.messages.forEach(m => {
                    if (m.direction === "in") {
                        m.read = true;
                    }
                });

                document.querySelectorAll(".chat").forEach(c => c.classList.remove("selected"));
                div.classList.add("selected");

                renderMessages();
                renderChats();
            };

            div.innerHTML = `
                <div class="phone">${conv.name ? conv.name + " · " : ""}${conv.phone}</div>
                <div class="when">${fmt(conv.last_ts)}</div>
            `;
            elChats.appendChild(div);
        });

        if (filtered.length === 0) {
            elChats.innerHTML = '<div class="empty" style="padding: 20px; text-align: center; color: #999;">No se encontraron conversaciones</div>';
        }
    }

    function renderMessages(){
        const conv = data.find(c => c.phone === selectedPhone);
        if(!conv){
            elTitle.textContent = "Selecciona un chat";
            elMsgs.innerHTML = `<div class="empty">No hay chat seleccionado</div>`;
            return;
        }
        elTitle.textContent = `${conv.name ? conv.name+" · " : ""}${conv.phone}`;
        elMsgs.innerHTML = "";
        conv.messages.forEach(m=>{
            const b = document.createElement("div");
            b.className = "bubble " + (m.direction === "out" ? "out" : "in");
            const status = m.direction === "out" ? ` · ${m.status||"sent"}` : "";
            b.innerHTML = `
                <div>${(m.text||"").replace(/</g,"&lt;")}</div>
                <div class="meta">${fmt(m.ts)}${status}</div>
            `;
            elMsgs.appendChild(b);
            elMsgs.scrollTop = elMsgs.scrollHeight;
        });
    }

    async function load() {
        try {
            const res = await fetch("/api/messages");
            const newData = await res.json();

            newData.forEach(conv => {
                const oldConv = data.find(c => c.phone === conv.phone);

                if (oldConv) {
                    // Conservar estado de lectura existente
                    conv.messages.forEach((m, idx) => {
                        const oldMsg = oldConv.messages[idx];
                        if (oldMsg) {
                            m.read = oldMsg.read;
                        } else if (m.direction === "in") {
                            // Nuevo mensaje entrante
                            m.read = false;
                        }
                    });
                } else {
                    // Nueva conversación: marcar entrantes como no leídos
                    conv.messages.forEach(m => {
                        if (m.direction === "in") {
                            m.read = false;
                        }
                    });
                }
            });

            data = newData;
            renderChats();
            if (selectedPhone) {
                renderMessages();
            }
        } catch (err) {
            console.error("Error al cargar mensajes:", err);
        }
    }

    elSend.onclick = async ()=>{
        const to = (elTo.value||"").trim();
        const text = (elText.value||"").trim();
        if(!to || !text) return alert("Completa teléfono y mensaje");
        const r = await fetch("/api/send", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ to, text })
        });
        const j = await r.json();
        if(!r.ok){
            console.error(j);
            return alert("Error al enviar: " + (j?.details?.error?.message || j.error));
        }
        elText.value = "";
        selectedPhone = to;
        await load();
    };

    load();
    setInterval(load, 4000);
</script>
</body>
</html>
